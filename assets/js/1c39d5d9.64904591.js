"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1431],{9824:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"Tutorials/Tutorial-\u2010-Step-3","title":"Step 3: Adding Interactions","description":"Objectives","source":"@site/docs/Tutorials/Tutorial-\u2010-Step-3.md","sourceDirName":"Tutorials","slug":"/Tutorials/Tutorial-\u2010-Step-3","permalink":"/Tutorials/Tutorial-\u2010-Step-3","draft":false,"unlisted":false,"editUrl":"https://github.com/project-SIMPLE/documentation/tree/main/docs/Tutorials/Tutorial-\u2010-Step-3.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docSidebar","previous":{"title":"Step 2: Creation of the Unity basic game","permalink":"/Tutorials/Tutorial-\u2010-Step-2"},"next":{"title":"Tutorials","permalink":"/Tutorials/"}}');var i=n(4848),o=n(8453);const r={},s="Step 3: Adding Interactions",c={},l=[{value:"Objectives",id:"objectives",level:2},{value:"Modification of the GAMA model",id:"modification-of-the-gama-model",level:3},{value:"Traffic and Pollution.gaml",id:"traffic-and-pollutiongaml",level:4},{value:"Traffic and Pollution-VR.gaml",id:"traffic-and-pollution-vrgaml",level:4},{value:"Modification of the Unity project",id:"modification-of-the-unity-project",level:3},{value:"Other types of interactions",id:"other-types-of-interactions",level:3}];function d(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",p:"p",pre:"pre",...(0,o.RP)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"step-3-adding-interactions",children:"Step 3: Adding Interactions"})}),"\n",(0,i.jsx)(t.h2,{id:"objectives",children:"Objectives"}),"\n",(0,i.jsx)(t.p,{children:"The aim here is to enable simple interactions from the VR headset. In particular, we want to be able to block roads by selecting them with the interaction ray. We'll then look at other types of interaction, with the example of using a button on one of the controllers to change the brightness."}),"\n",(0,i.jsx)(t.h3,{id:"modification-of-the-gama-model",children:"Modification of the GAMA model"}),"\n",(0,i.jsx)(t.h4,{id:"traffic-and-pollutiongaml",children:"Traffic and Pollution.gaml"}),"\n",(0,i.jsx)(t.p,{children:'First, we will modify the "Traffic and Pollution.gaml" file to integrate the notion of blocked roads.\nIn the road species, we will add a boolean blocked attribute (initial value: false), and change the color of blocked road from white to red.'}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-gaml",children:"species road {\n\t...\n\t\n\tbool blocked <- false;\n\n\taspect default {\n\t\tdraw (shape + 5) color:blocked ? #red: #white;\n\t}\n\n}\n\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"TutorialGAMARoad",src:n(9235).A+"",width:"2464",height:"1250"})}),"\n",(0,i.jsx)(t.p,{children:"We will then modify the reflex update_road_speed of the global section to take into account the fact that speed on a blocked road will be close to 0."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-gaml",children:"//Reflex to update the speed of the roads according to the weights\nreflex update_road_speed {\n\troad_weights <- road as_map (each::(each.shape.perimeter / each.speed_coeff * (each.blocked ? 100000.0 : 1.0)));\n\troad_network <- road_network with_weights road_weights;\n}\n\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"TutorialGAMAGlobal",src:n(4492).A+"",width:"2820",height:"1476"})}),"\n",(0,i.jsx)(t.p,{children:'Finally, we will modify the "carte" display to be able to see the change for the display of roads. For that, just change the line "species road refresh: false;" by "species road refresh: true;".'}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"TutorialGAMADisplay",src:n(8211).A+"",width:"1764",height:"1478"})}),"\n",(0,i.jsx)(t.h4,{id:"traffic-and-pollution-vrgaml",children:"Traffic and Pollution-VR.gaml"}),"\n",(0,i.jsx)(t.p,{children:"We're going to add an action to block a specific road (based on its name) in the Unity Linker species. In order to make a direct link between roads and their names, we've defined a map called \"roads\" that allows you to obtain the right road directly from a road name. This action will be called directly from Unity. If the route is not null, if the route is already blocked, the action will unblock it, and block it otherwise."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-gaml",children:"\tmap<string,road> roads <- road as_map (each.name :: each);\n\t\n\taction block_road(string id) {\n\t\troad b <- roads[id];\n\t\tif (b != nil) {\n\t\t\task b {\n\t\t\t\tif (not blocked) {\n\t\t\t\t\tblocked <- true;\n\t\t\t\t} else {\n\t\t\t\t\tblocked <- false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"TutorialGAMAUnityLinker",src:n(1603).A+"",width:"2570",height:"1162"})}),"\n",(0,i.jsx)(t.h3,{id:"modification-of-the-unity-project",children:"Modification of the Unity project"}),"\n",(0,i.jsx)(t.p,{children:'The first step is to extend the ray interaction distance.\nInspect "GodViewPlayer/XR Origin (XR Rig)/Camera Offset/Right Controller/Ray Interactor", then set the "Max Raycast Distance" (in "XR Ray Interactor/Raycast Configuration") to 500 and in "XR Interactor Line Visual" uncheck "Override Line Length".'}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"TutorialRayInteractor",src:n(1210).A+"",width:"3206",height:"2210"})}),"\n",(0,i.jsx)(t.p,{children:"The second step is to specify what will happen when the player points the ray at a route and selects it.\nOpen the script Assets/Gama Provider/SimulationManagerInteraction. In this script, 3 functions control the XR-interaction: HoverEnterInteraction, HoverExitInteraction and SelectInteraction."}),"\n",(0,i.jsx)(t.p,{children:'HoverEnterInteraction specifies what happens when the player passes over an object that can be interacted with. In the tutorial we want to change the color to blue when the ray passes over a road. So if the object the ray is hovering over has the tag "road", change its color to blue.'}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cs",children:'   //Defines what happens when a ray passes over an object \n    protected override void HoverEnterInteraction(HoverExitEventArgs ev)\n    {\n        GameObject obj = ev.interactableObject.transform.gameObject;\n        if (obj.tag.Equals("road"))\n            ChangeColor(obj, Color.blue);\n    }\n'})}),"\n",(0,i.jsx)(t.p,{children:'HoverExitInteraction specifies what happens when the player is no longer in contact with an object that can be interacted with. In the tutorial, the object if its tag is "road" changes color and reverts to gray if not selected, or red otherwise.'}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cs",children:'   //Defines what happens when a ray passes not anymore over an object \n    protected override void HoverExitInteraction(HoverExitEventArgs ev)\n    {\n        GameObject obj = ev.interactableObject.transform.gameObject;\n        if (obj.tag.Equals("road"))\n        {\n            bool isSelected = SelectedObjects.Contains(obj);\n            ChangeColor(obj, isSelected ? Color.red : Color.gray);\n        }\n    }\n'})}),"\n",(0,i.jsx)(t.p,{children:'SelectInteraction specifies what happens when the player selects an object (by default using the controller\'s second trigger - the white button along the handle). In the tutorial, if it\'s an object with the "road" tag, Unity will trigger the GAMA action "block_road" which takes the name of the selected object as an argument and change the color of the object to red. Note that to prevent the player from pressing several times on the object too quickly, a timer is used to prevent a second action before "timeWithoutInteraction" seconds (set to 1s by default).'}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cs",children:'//Defines what happens when a object is selected\n    protected override void SelectInteraction(SelectEnterEventArgs ev)\n    {\n        if (remainingTime <= 0.0)\n        {\n            GameObject obj = ev.interactableObject.transform.gameObject;\n            if (("road").Equals(obj.tag))\n            {\n                Dictionary<string, string> args = new Dictionary<string, string> {\n                         {"id", obj.name }\n                    };\n                ConnectionManager.Instance.SendExecutableAsk("block_road", args);\n                bool newSelection = !SelectedObjects.Contains(obj);\n                if (newSelection)\n                    SelectedObjects.Add(obj);\n                else\n                    SelectedObjects.Remove(obj);\n                ChangeColor(obj, newSelection ? Color.red : Color.gray);\n                remainingTime = timeWithoutInteraction;\n            }\n        }\n    }\n'})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"TutorialSelectInteraction",src:n(3919).A+"",width:"792",height:"854"})}),"\n",(0,i.jsx)(t.h3,{id:"other-types-of-interactions",children:"Other types of interactions"}),"\n",(0,i.jsx)(t.p,{children:'It\'s possible to go further in specifying interactions. In particular, it is possible to define exactly what will happen when the player uses a specific button/stick on the controller. To do this, a first step consists in defining a specific action by editing the "XRI Default Input Actions" file in "Assets/Samples/XR Interaction Tookit/2.4.3/Starter Assets". Double-click on this file to open it. Specific actions can be added afterwards. For example, in "XRI RightHand Interaction", we\'ve added a "Main Button" action of type "Button".  In the Path, we specified that this action will be triggered by the main button on the right-hand controller.'}),"\n",(0,i.jsx)(t.p,{children:"To be able to use this action, we added a SerializedField in the SimulationManager Script:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cs",children:"[SerializeField] private InputActionReference primaryRightHandButton; \n"})}),"\n",(0,i.jsx)(t.p,{children:"And in the Game Manager, we drag and drop the MainButton action to this field. Then, in the update function (that is activated at each frame),in order to trigger the TriggerMainButton when the main button is pushed we added:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cs",children:" if (primaryRightHandButton != null && primaryRightHandButton.action.triggered) {\n       TriggerMainButton();\n }\n"})}),"\n",(0,i.jsx)(t.p,{children:'Note that what happens when the main button is triggered can be defined using the "TriggerMainButton" method in the SimulationManagerInteraction class.'})]})}function h(e={}){const{wrapper:t}={...(0,o.RP)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8211:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/TutorialGAMADisplay-61f91ebf1eb455a157b4571ad9685817.png"},4492:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/TutorialGAMAGlobal-ed1aea58e31fe557da5682dc499ee1f0.png"},9235:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/TutorialGAMARoad-c6e44158b6ba7d4496a6500d875148b3.png"},1603:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/TutorialGAMAUnityLinker-25f8ea57270b56edc914b5ed307077bd.png"},1210:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/TutorialRayInteractor-0cc9bfadf71667d66c8ceb1b0996c500.png"},3919:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/TutorialSelectInteraction-690a7cdf6e3bdc1426d0ad93adc04530.png"},8453:(e,t,n)=>{n.d(t,{RP:()=>o,xA:()=>s});var a=n(6540);const i=a.createContext({});function o(e){const t=a.useContext(i);return a.useMemo((()=>"function"==typeof e?e(t):{...t,...e}),[t,e])}const r={};function s({components:e,children:t,disableParentContext:n}){let s;return s=n?"function"==typeof e?e({}):e||r:o(e),a.createElement(i.Provider,{value:s},t)}}}]);